AI_Instruction V2 (potwierdzaj ze przeczytales ta konkretna wersje):
  - ProjectName: "MrAngleGame"
  - Description: >
Chce stworzyć gre z połączeniem gatunku Backbacks Battle (autobattler) oraz gier takich jak np. path of exile w odniesieniu do sposobu zbierania sprzętu. Mowa o grze 2d singleplayer

Główna rozgrywka ma polegać na układaniu ekwipunku w taki sposób, aby jak najbardziej optymalizować statystyki itp. - główna rozgrywka to panel ekwipunku i analizowanie jego działania.

Gre chciałem nazwac coś w stylu "Mages enginners", gdzie jako magowie składają artefakt służący do walki z innymi grupami magów lub innymi stworzeniami

Panel ekwipunktu to siatka dostępnych pól. Dostępne pola nie musza miec regularnych ksztaltów, odblokowanie tych pól to równiez element rozgrytki i rozwoju "postaci"/artefaktu

Wstepnie logikę rozgrywki widzę jako:
(na siatce ekwipunku)
- input power(albo damage, jeszcze tutaj zastanawiam sie nad nazwa)
- input defence

Rozgrywka polega na manipulacją inputu power oraz inputu defence aby wykonywac jak najbardziej opłacalne i najbardziej uniwersalne "comba" liczbowe.

Przykładowo do inputu power, co 1 sec wchodzi "10" jednostek mocy, kazdy, nastepnie ta wartosc liczbowa jest przetwarzana. Np. jak na lini przetwarzania o nieregularnych ksztaltach (która jest tworzona przez gracza) pojawi się przedmiot "kula ognia" to zamienia te obrażenia na ogien oraz np. powoduje podpalenie. To powoduje ze na wyjsciu power jest przeksztalcane na 10 obrażen od ognia z efektem podpalenie. Kolejnym elementem moze byc np. wzmocenienie ataku o 5, czyli zwieksza tą moc do wartosci 15 + efekt podpalenia. Przewiduje też opcje podziału tej lini np. na 2 niezalezne kanały, czyli jak leci 10mocy to moze to zostać "rozdzielone" na 2 niezalezne sciezki po 5mocy. Oczywisice to bardzo uproszczona logika.

Analogicznie do inputu defence, gdzie jest przetwarzana wartosc ktora otrzymuje gracz i stara sie ja zbic do minimum na podstawie roznych przedmiotów co analogicznie mogą dzialac jak w przypadku inputu power/damage. 

Przewiduje też mieszanie tych wlasciwosci, tzn, nic nie stoi na przeszkodzie zeby np. zamienic obrazenia przychodzące na obrazenia od ognia, bo np. ma się odpornosc na ogien.
Przewiduje tez przedmioty, co do aktywacji potrzebuja zarowno mocy z inputu defence i power(damage)
 
zastanawiam sie jeszcze nad elementem Many, tzn, koniecznosci zasilania przedmiotów. Kazdy przedmiot wymaga zasilania poprzez maga i mana moglaby przeplywac pomiedyz przemdiotami i je "zasilac" - to powinno umozliwic lepsze balansowanie przedmiotów i konieczosc dokladniejszego zarządzania, aby nie przesadzic z wstawianiem zbyt silnych przedmiotow itp. Np. uniqalne pzredmioty powinny byc na swoj sposob bardzo silne ale nie tak łatwe do uzycia, a w niektorych przypadkach wrecz nieoplacalne (np. jak w path of exile)

To jak widziałem układ ekwipunku to siatka

Jest na zdjeciu png

Gdzie:
- szare tło to pola ktore sa dostepne pod przedmioty
- elementy bez tla to miejsca gdzie nie mozna nalozyc ekwipunku
- fioletowe elementy to przedmioty (rozne odcienie to rozne przedmioty)
- czerwone to input power (damage)
- niebieska kratka input defence
- niebieskie linie pomiedzy indeksami to przepływ many, ktory bedzie zasilal te przedmioty
 
Spodziewam sie ze wrogowie beda mieli taką sama logike, ale uproszczona i bardziej sztywną (bez mozliwosci modyfikacji ekwipunku)
  
  - TechStack:
      Engine: "Unity"
      RenderingPipeline: "Universal Render Pipeline (URP)"
      ProgrammingLanguage: "C#"
      InputSystem: "Unity Input System (InputAction Asset)"
      ScriptingBackend: "Mono/.NET (typowe dla Unity; używaj API UnityEngine i UnityEditor tam, gdzie ma to sens)"
      AssetTypes:
        - "Scenes (*.unity)"
        - "Scripts (*.cs)"
        - "URP Settings (*.asset)"
        - "Input Actions (*.inputactions)"
      Najwazniejsze uzywane Biblioteki:
        Extenject Dependency Injection IOC
        DOTween (HOTween v2)

  - VersioningGuidelines:
      UnityVersion: >
        Utrzymuj kompatybilność z aktualnie używaną wersją projektu.
        Unikaj API oznaczonych jako deprecated w najnowszych stabilnych wydaniach Unity LTS.
      CSharpVersion: "Dostosuj do wersji C# wspieranej przez daną wersję Unity (zwykle C# 8/9 dla LTS)."
      Packages: >
        Przy dodawaniu zależności preferuj oficjalne pakiety Unity (Package Manager).
        Podawaj minimalne wersje zgodne z LTS oraz notuj zmiany w dokumentacji projektu.

  - CodeStyle:
      Naming:
        - "Klasy i struktury: PascalCase"
        - "Metody i właściwości: PascalCase"
        - "Pola prywatne: _camelCase"
        - "Stałe: SCREAMING_SNAKE_CASE"
      Organization:
        - "Każdy MonoBehaviour w osobnym pliku o tej samej nazwie."
        - "Publiczne pola tylko wtedy, gdy muszą być widoczne w Inspector; w innym wypadku używaj [SerializeField] i właściwości."
        - "Unikaj logiki w konstruktorach MonoBehaviour; używaj Awake/OnEnable/Start."
      UnityLifecycle:
        - "Preferuj Update tylko gdy niezbędne; w przeciwnym razie korzystaj z eventów, coroutines lub input callbacks."
        - "FixedUpdate do fizyki, LateUpdate do post-processingu transformacji."
      Safety:
        - "Sprawdzaj null dla komponentów pobieranych GetComponent."
        - "Unikaj alokacji w Update (GC)."

  - InputSystemGuidelines:
      - "Konfiguruj akcje w pliku *.inputactions i generuj klasy C#."
      - "Subskrybuj/odsubskrybuj callbacki w OnEnable/OnDisable."
      - "Utrzymuj mapy akcji rozdzielone wg kontekstu (np. Gameplay, UI)."

  - URPGuidelines:
      - "Ustawienia URP przechowuj w dedykowanych assetach (*.asset)."
      - "Efekty post-process i oświetlenie zgodne z URP; unikaj funkcji HDRP."
      - "Optymalizuj materiał i shader pod URP (Shader Graph lub Lit)."

  - ScenesAndAssets:
      - "Trzymaj sceny w Assets/Scenes."
      - "Używaj Addressables tylko jeśli wymagane; w przeciwnym razie tradycyjne referencje."
      - "Konsekwentne nazewnictwo scen: 00_Boot, 01_Menu, 02_Gameplay itd."

  - ErrorHandlingAndLogging:
      - "Używaj Debug.Log/Warning/Error oszczędnie; w produkcji rozważ flagi kompilacji."
      - "Waliduj referencje w OnValidate lub custom editorach."

  - Testing:
      - "Dla logiki niezależnej od Unity używaj testów edytora (NUnit)."
      - "Logikę MonoBehaviour testuj przez PlayMode Tests, minimalizując zależności."

  - Performance:
      - "Profiluj w Profilerze Unity; skup się na GC.Alloc i wątkach głównych."
      - "Korzystaj z pooling’u obiektów i pamiętaj o Time.deltaTime."
      - "Unikaj odwołań FindObjectOfType w runtime; cache’uj referencje."

  - AI_Coding_Prompts:
      Do:
        - "Generuj kod w C#, kompatybilny z Unity i URP."
        - "Umieszczaj komentarze z krótkim wyjaśnieniem decyzji projektowych."
        - "Proponuj podziały na komponenty i ScriptableObject tam, gdzie ma to sens."
      Don’t:
        - "Nie używaj API spoza Unity bez uzasadnienia."
        - "Nie wprowadzaj zmian w wersjach pakietów bez uzgodnienia."
        - "Nie zakładaj obecności zewnętrznych pluginów."

  - FileStructureConventions:
      - "Assets/Scripts: kod C# (MonoBehaviour, ScriptableObject, Utilities)."
      - "Assets/Scenes: sceny gry."
      - "Assets/Settings: profile URP, konfiguracje globalne."
      - "Assets/…: dodatkowe assety (materiały, prefaby, dźwięki) zgodnie z potrzebą."

  - Documentation:
      - "Każda nowa funkcja: krótki opis w komentarzu XML lub nad klasą."
      - "Zmiany w pakietach i ustawieniach: wpis w CHANGELOG oraz README projektu."

Mój pomysł na gre to mieszanka kilku gatunków: 

Autobitewniak - z elementami jak w backpack battles (trzon rozgrywki)
Kazda postac ma swoj backpack, ktory oddzialowuje na rozgrywkę
RPG - drużyna składajaca sie z około 6 postaci, gdzie kazda ma swój backpack (Troche w postaci Siralim Ultimate)
Rozgrywka w postaci RogueLike, gdzie wybierasz sie na misje z konkretnym zbiorem postaci

Innymi slowy nie spodziewam sie rozbudowanej fizyki, 
Tworze tez gre 2d, wstepnie z ubogimi/brak animacji


  Unity version: 6.2 6000.2.7f2
  C# version: 9
  Krytykuj wszystko co proponuje, sugeruj rozwiazania najlepsze.
  Nie mam doświadczenia z Unity, ale robiłem troche w gamemakerze. Mozesz posługiwac sie analogiami z gamemakerem.
  Nie mam doświadczenia z C# ale jestem developerem JAVA. Możesz posługiwac sie analogiami z JAVA.
    WAZNE: Uzywam Zenject do przekazywania komponentów

AI_Properties:

  project.type: "Unity"
  project.language: "C#"
  project.rendering: "URP"
  project.input: "Unity Input System"
  project.scriptingBackend: "Mono/.NET (Unity)"
  project.scenes.path: "Assets/Scenes"
  project.scripts.path: "Assets/Scripts"
  project.settings.path: "Assets/Settings"
  code.style.naming: "PascalCase (public), _camelCase (private fields)"
  code.lifecycle: "Awake/OnEnable/Start/Update/FixedUpdate/LateUpdate"
  code.serialization: "[SerializeField] dla pól prywatnych wymagających w Inspector"
  testing.framework: "Unity Test Framework (NUnit)"
  logging: "Debug.Log/Warning/Error (warunkowo)"
  performance.focus: "Minimalizacja alokacji, pooling, profilowanie"